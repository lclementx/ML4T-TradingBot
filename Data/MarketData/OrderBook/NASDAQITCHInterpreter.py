from pathlib import Pathfrom collections import Counterfrom datetime import timedeltafrom datetime import datetimefrom time import timefrom Utils import TimeUtils as tufrom tqdm import tqdmimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.patches as mpatchesimport seaborn as snsclass NASDAQITCHInterpreter():        basePath = '/Users/clemmie/Documents/Python/TradingBot/Data/MarketData/Resources/'    order_dict = {-1: 'sell', 1: 'buy'}    stock = ""    store_path = basePath + 'nasdaq_order_book.h5'    def __init__(self, stock):        self.stock = stock        def get_messages(self, date, stock="", itch_store=basePath + 'nasdaq_itch.h5', store_messages=True):        """Collect trading messages for given stock"""        with pd.HDFStore(itch_store) as store:            stock_locate = store.select('R', where='stock = stock').stock_locate.iloc[0].item()            target = 'stock_locate = stock_locate'                data = {}            # trading message types            messages = ['A', 'F', 'E', 'C', 'X', 'D', 'U', 'P', 'Q']            for m in messages:                data[m] = store.select(m, where=target).drop('stock_locate', axis=1).assign(type=m)            order_cols = ['order_reference_number', 'buy_sell_indicator', 'shares', 'price']        orders = pd.concat([data['A'], data['F']], sort=False, ignore_index=True).loc[:, order_cols]            for m in messages[2: -3]:            data[m] = data[m].merge(orders, how='left')            data['U'] = data['U'].merge(orders, how='left',                                    right_on='order_reference_number',                                    left_on='original_order_reference_number',                                    suffixes=['', '_replaced'])            data['Q'].rename(columns={'cross_price': 'price'}, inplace=True)        data['X']['shares'] = data['X']['cancelled_shares']        data['X'] = data['X'].dropna(subset=['price'])            data = pd.concat([data[m] for m in messages], ignore_index=True, sort=False)        data['date'] = pd.to_datetime(date, format='%m%d%Y')        data.timestamp = data['date'].add(data.timestamp)        data = data[data.printable != 0]            drop_cols = ['tracking_number', 'order_reference_number', 'original_order_reference_number',                     'cross_type', 'new_order_reference_number', 'attribution', 'match_number',                     'printable', 'date', 'cancelled_shares']                data = data.drop(drop_cols, axis=1).sort_values('timestamp').reset_index(drop=True)                if store_messages:            messages_path = f"{stock}/messages"            with pd.HDFStore(self.store_path) as store:                store.put(messages_path, data)                        return data        def get_trades(self, messages, store_trades=True):        """Combine C, E, P and Q messages into trading records"""        trade_dict = {'executed_shares': 'shares', 'execution_price': 'price'}        cols = ['timestamp', 'executed_shares']        trades = pd.concat([messages.loc[messages.type == 'E', cols + ['price']].rename(columns=trade_dict),                            messages.loc[messages.type == 'C', cols + ['execution_price']].rename(columns=trade_dict),                            messages.loc[messages.type == 'P', ['timestamp', 'price', 'shares']],                            messages.loc[messages.type == 'Q', ['timestamp', 'price', 'shares']].assign(cross=1),                            ], sort=False).dropna(subset=['price']).fillna(0)        trades = trades.set_index('timestamp').sort_index().astype(int)                if store_trades:            trades_path = f"{self.stock}/trades"            with pd.HDFStore(self.store_path) as store:                store.put(trades_path, trades)                return         def add_orders(self, orders, buysell, nlevels):        """Add orders up to desired depth given by nlevels;            sell in ascending, buy in descending order        """        new_order = []        items = sorted(orders.copy().items())        if buysell == 1:            items = reversed(items)          for i, (p, s) in enumerate(items, 1):            new_order.append((p, s))            if i == nlevels:                break        return orders, new_order        def save_orders(self, orders, append=False):        cols = ['price', 'shares']        for buysell, book in orders.items():            df = (pd.concat([pd.DataFrame(data=data,                                         columns=cols)                             .assign(timestamp=t)                              for t, data in book.items()]))            key = f'{self.stock}/{self.order_dict[buysell]}'            df.loc[:, ['price', 'shares']] = df.loc[:, ['price', 'shares']].astype(int)                        with pd.HDFStore(self.store_path) as store:                if append:                    store.append(key, df.set_index('timestamp'), format='t')                else:                    store.put(key, df.set_index('timestamp'), format='t')            def get_orders(self,messages):        order_book = {-1: {}, 1: {}}        current_orders = {-1: Counter(), 1: Counter()}        message_counter = Counter()        nlevels = 100                start = time()        for message in tqdm(messages.itertuples()):            i = message[0]            if i % 1e5 == 0 and i > 0:                print(f'{i:,.0f}\t\t{tu.format_time(time() - start)}')                self.save_orders(order_book, append=True)                order_book = {-1: {}, 1: {}}                start = time()            if np.isnan(message.buy_sell_indicator):                continue            message_counter.update(message.type)                    buysell = message.buy_sell_indicator            price, shares = None, None                    if message.type in ['A', 'F', 'U']:                price = int(message.price)                shares = int(message.shares)                        current_orders[buysell].update({price: shares})                current_orders[buysell], new_order = self.add_orders(current_orders[buysell], buysell, nlevels)                order_book[buysell][message.timestamp] = new_order                    if message.type in ['E', 'C', 'X', 'D', 'U']:                if message.type == 'U':                    if not np.isnan(message.shares_replaced):                        price = int(message.price_replaced)                        shares = -int(message.shares_replaced)                else:                    if not np.isnan(message.price):                        price = int(message.price)                        shares = -int(message.shares)                        if price is not None:                    current_orders[buysell].update({price: shares})                    if current_orders[buysell][price] <= 0:                        current_orders[buysell].pop(price)                    current_orders[buysell], new_order = self.add_orders(current_orders[buysell], buysell, nlevels)                    order_book[buysell][message.timestamp] = new_order                    