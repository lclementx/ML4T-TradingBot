#!/usr/bin/env python3# -*- coding: utf-8 -*-from pathlib import Pathfrom collections import Counterfrom datetime import timedeltafrom datetime import datetimefrom time import timefrom Utils import TimeUtils as tufrom tqdm import tqdmfrom math import pifrom bokeh.plotting import figure, showfrom scipy.stats import normaltestimport pandas as pdimport numpy as npimport matplotlib as mplimport matplotlib.pyplot as pltimport matplotlib.patches as mpatchesfrom matplotlib.ticker import FuncFormatterimport seaborn as sns"""Created on Mon Jan 22 16:50:13 2024@author: clemmie"""class OrderBookAnalysis():        def __init__(self,store_path,stock,date,market_open='0930',market_close='1600',utc_offset=timedelta(hours=4)):        self.stock = stock        self.buy, self.sell = self.load_buy_sell_from_path(store_path,stock)        self.trades = self.load_trades_from_path(store_path,stock)        self.date = date        self.market_open = market_open        self.market_close = market_close        self.utc_offset = utc_offset        def load_buy_sell_from_path(self,store_path,stock):                with pd.HDFStore(store_path) as store:            buy = store[f'{stock}/buy'].reset_index().drop_duplicates()            sell = store[f'{stock}/sell'].reset_index().drop_duplicates()                #Price to Decimals for sanity        buy.price = buy.price.mul(1e-4)        sell.price = sell.price.mul(1e-4)                        # percentiles = [.01, .02, .1, .25, .75, .9, .98, .99]        # buy_sell_stats = pd.concat([self.buy.price.describe(percentiles=percentiles).to_frame('buy'),        #             self.sell.price.describe(percentiles=percentiles).to_frame('sell')], axis=1)                #Remove Outiers TODO: make this optional later        buy = buy[buy.price > buy.price.quantile(.01)]        sell = sell[sell.price < sell.price.quantile(.99)]        return buy, sell        def load_trades_from_path(self,store_path,stock):        with pd.HDFStore(store_path) as store:                trades = store[f'{stock}/trades']        return trades        def limit_order_price_distribution(self):        buy, sell = self.buy, self.sell        #Price Distribution        fig, ax = plt.subplots(figsize=(7,5))        hist_kws = {'linewidth': 1, 'alpha': .5}        sns.distplot(buy[buy.price.between(0, 250)].set_index('timestamp').between_time(self.market_open,self.market_close).price,                       ax=ax, label='Buy', kde=False, hist_kws=hist_kws)        sns.distplot(sell[sell.price.between(0, 250)].set_index('timestamp').between_time(self.market_open, self.market_close).price,                       ax=ax, label='Sell', kde=False, hist_kws=hist_kws)        ax.legend(fontsize=10)        ax.set_title('Limit Order Price Distribution')        ax.set_yticklabels([f'{int(y/1000):,}' for y in ax.get_yticks().tolist()])        ax.set_xticklabels([f'${int(x):,}' for x in ax.get_xticks().tolist()])        ax.set_xlabel('Price')        ax.set_ylabel('Shares (\'000)')        sns.despine()        fig.tight_layout()        def order_book_depth(self,depth=100):                buy_per_min = (self.buy                        .groupby([pd.Grouper(key='timestamp', freq='Min'), 'price'])                        .shares                        .sum()                        .apply(np.log)                        .to_frame('shares')                        .reset_index('price')                        .between_time(self.market_open, self.market_close)                        .groupby(level='timestamp', as_index=False, group_keys=False)                        .apply(lambda x: x.nlargest(columns='price', n=depth))                        .reset_index())        buy_per_min.timestamp = buy_per_min.timestamp.add(self.utc_offset).astype(int)        buy_per_min.info()        sell_per_min = (self.sell                        .groupby([pd.Grouper(key='timestamp', freq='Min'), 'price'])                        .shares                        .sum()                        .apply(np.log)                        .to_frame('shares')                        .reset_index('price')                        .between_time(self.market_open, self.market_close)                        .groupby(level='timestamp', as_index=False, group_keys=False)                        .apply(lambda x: x.nsmallest(columns='price', n=depth))                        .reset_index())        sell_per_min.timestamp = sell_per_min.timestamp.add(self.utc_offset).astype(int)        sell_per_min.info()                trades = self.trades                    trades.price = trades.price.mul(1e-4)        trades = trades[trades.cross == 0].between_time(self.market_open, self.market_close)        trades_per_min = (trades                          .resample('Min')                          .agg({'price': 'mean', 'shares': 'sum'}))        trades_per_min.index = trades_per_min.index.to_series().add(self.utc_offset).astype(int)        trades_per_min.info()        sns.set_style('white')        fig, ax = plt.subplots(figsize=(14, 6))        buy_per_min.plot.scatter(x='timestamp',                                  y='price',                                   c='shares',                                   ax=ax,                                   colormap='Blues',                                   colorbar=False,                                   alpha=.25)        sell_per_min.plot.scatter(x='timestamp',                                  y='price',                                   c='shares',                                   ax=ax,                                   colormap='Reds',                                   colorbar=False,                                   alpha=.25)        title = f'AAPL | {self.date} | Buy & Sell Limit Order Book | Depth = {depth}'        trades_per_min.price.plot(figsize=(14, 8),                                   c='k',                                   ax=ax,                                   lw=2,                                   title=title)        xticks = [datetime.fromtimestamp(ts / 1e9).strftime('%H:%M') for ts in ax.get_xticks()]        ax.set_xticklabels(xticks)        ax.set_xlabel('')        ax.set_ylabel('Price', fontsize=12)        red_patch = mpatches.Patch(color='red', label='Sell')        blue_patch = mpatches.Patch(color='royalblue', label='Buy')        plt.legend(handles=[red_patch, blue_patch])        sns.despine()        fig.tight_layout()        def tick_bars(self):        tick_bars = self.trades.copy()        tick_bars.index = tick_bars.index.time        tick_bars.price.plot(figsize=(10, 5),                              title='Tick Bars | {} | {}'.format(self.stock, pd.to_datetime(self.date).date()), lw=1)        plt.xlabel('')        plt.tight_layout()        return tick_bars        def price_volume(self, df, price='vwap', vol='vol',                      suptitle='{self.stock} | {pd.to_datetime(self.date).date()}', fname=None,                     bar_shrink_factor=5):        fig, axes = plt.subplots(nrows=2, sharex=True, figsize=(15,8))        axes[0].plot(df.index, df[price])        axes[1].bar(df.index, df[vol], width=1/(bar_shrink_factor*len(df.index)), color='r')                # formatting         xfmt = mpl.dates.DateFormatter('%H:%M')        axes[1].xaxis.set_major_locator(mpl.dates.HourLocator(interval=3))        axes[1].xaxis.set_major_formatter(xfmt)        axes[1].get_xaxis().set_tick_params(which='major', pad=25)        axes[0].set_title('Price', fontsize=14)        axes[1].set_title('Volume', fontsize=14)        fig.autofmt_xdate()        fig.suptitle(suptitle)        fig.tight_layout()        plt.subplots_adjust(top=0.9)            def get_bar_stats(self, agg_trades):        vwap = agg_trades.apply(lambda x: np.average(x.price, weights=x.shares)).to_frame('vwap')        ohlc = agg_trades.price.ohlc()        vol = agg_trades.shares.sum().to_frame('vol')        txn = agg_trades.shares.size().to_frame('txn')        return pd.concat([ohlc, vwap, vol, txn], axis=1)            def time_bars(self,freq='1MIN'):        resampled = self.trades.groupby(pd.Grouper(freq=freq))        print(resampled.describe())        time_bars = self.get_bar_stats(resampled)        self.price_volume(time_bars,              suptitle=f'Time Bars | {self.stock} | {pd.to_datetime(self.date).date()}',              fname='time_bars')        return time_bars                    def volume_bars(self):        trades = self.trades.copy()        trades_per_min = trades.shares.sum()/(60*7.5) # min per trading day        trades['cumul_vol'] = trades.shares.cumsum()        df = trades.reset_index()        by_vol = df.groupby(df.cumul_vol.div(trades_per_min).round().astype(int))        vol_bars = pd.concat([by_vol.timestamp.last().to_frame('timestamp'), self.get_bar_stats(by_vol)], axis=1)        print(vol_bars.head())        self.price_volume(vol_bars.set_index('timestamp'),              suptitle=f'Volume Bars | {self.stock} | {pd.to_datetime(self.date).date()}',              fname='volume_bars')        return vol_bars        def dollar_bars(self):        trades = self.trades.copy()        value_per_min = trades.shares.mul(trades.price).sum()/(60*7.5) # min per trading day        trades['cumul_val'] = trades.shares.mul(trades.price).cumsum()        df = trades.reset_index()        by_value = df.groupby(df.cumul_val.div(value_per_min).round().astype(int))        dollar_bars = pd.concat([by_value.timestamp.last().to_frame('timestamp'), self.get_bar_stats(by_value)], axis=1)        print(dollar_bars.head())        self.price_volume(dollar_bars.set_index('timestamp'),              suptitle=f'Dollar Bars | {self.stock} | {pd.to_datetime(self.date).date()}',              fname='dollar_bars',bar_shrink_factor=1)        return dollar_bars                                